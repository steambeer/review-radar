"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Neynar API
 * The Neynar API allows you to interact with the Farcaster protocol among other things. See the [Neynar docs](https://docs.neynar.com/reference) for more details.
 *
 * The version of the OpenAPI document: 3.26.0
 * Contact: team@neynar.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LookupNeynarFrameTypeEnum = exports.FetchValidateFrameAnalyticsAggregateWindowEnum = exports.FetchValidateFrameAnalyticsAnalyticsTypeEnum = exports.FetchRelevantFramesTimeWindowEnum = exports.FetchFrameCatalogCategoriesEnum = exports.FetchFrameCatalogTimeWindowEnum = exports.FrameApi = exports.FrameApiFactory = exports.FrameApiFp = exports.FrameApiAxiosParamCreator = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
/**
 * FrameApi - axios parameter creator
 * @export
 */
const FrameApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete an existing mini app, if it was made by the developer (identified by API key)
         * @summary Delete mini app
         * @param {DeleteFrameReqBody} deleteFrameReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<DeleteFrameResponse>} A promise that resolves to a `DeleteFrameResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-neynar-frame)
         *
         */
        deleteNeynarFrame: async (deleteFrameReqBody, options = {}) => {
            // verify required parameter 'deleteFrameReqBody' is not null or undefined
            (0, common_1.assertParamExists)('deleteNeynarFrame', 'deleteFrameReqBody', deleteFrameReqBody);
            const localVarPath = `/v2/farcaster/frame/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(deleteFrameReqBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A curated list of featured mini apps
         * @summary Mini apps catalog
         * @param {number} [limit] Number of results to fetch  (Default: 100, Maximum: 100)
         * @param {string} [cursor] Pagination cursor
         * @param {FetchFrameCatalogTimeWindowEnum} [timeWindow] Time window used to calculate the change in trending score for each mini app, used to sort mini app results
         * @param {Array<FetchFrameCatalogCategoriesEnum>} [categories] Comma separated list of categories to include in the results. Includes all if left blank. Example: categories&#x3D;games,social OR categories&#x3D;games&amp;categories&#x3D;social
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-catalog)
         *
         */
        fetchFrameCatalog: async (limit, cursor, timeWindow, categories, options = {}) => {
            const localVarPath = `/v2/farcaster/frame/catalog/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (timeWindow !== undefined) {
                localVarQueryParameter['time_window'] = timeWindow;
            }
            if (categories) {
                localVarQueryParameter['categories'] = categories;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the mini app meta tags from the URL
         * @summary Meta tags from URL
         * @param {string} url The mini app URL to crawl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FetchFrameMetaTagsFromUrl200Response>} A promise that resolves to a `FetchFrameMetaTagsFromUrl200Response` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-meta-tags-from-url)
         *
         */
        fetchFrameMetaTagsFromUrl: async (url, options = {}) => {
            // verify required parameter 'url' is not null or undefined
            (0, common_1.assertParamExists)('fetchFrameMetaTagsFromUrl', 'url', url);
            const localVarPath = `/v2/farcaster/frame/crawl/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of mini apps made by the developer (identified by API key)
         * @summary List of mini apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<Array<NeynarFrame>>} A promise that resolves to a `Array<NeynarFrame>` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-neynar-frames)
         *
         */
        fetchNeynarFrames: async (options = {}) => {
            const localVarPath = `/v2/farcaster/frame/list/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of notifications tokens related to a mini app
         * @summary List of mini app notification tokens
         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)
         * @param {string} [fids] Comma separated list of FIDs, up to 100 at a time. If you pass in FIDs, you will get back the notification tokens for those FIDs. If you don\&#39;t pass in FIDs, you will get back all the notification tokens for the mini app.
         * @param {string} [cursor] Pagination cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameNotificationTokens>} A promise that resolves to a `FrameNotificationTokens` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notification-tokens)
         *
         */
        fetchNotificationTokens: async (limit, fids, cursor, options = {}) => {
            const localVarPath = `/v2/farcaster/frame/notification_tokens/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (fids !== undefined) {
                localVarQueryParameter['fids'] = fids;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of mini apps relevant to the user based on casts by users with strong affinity score for the user
         * @summary Relevant mini apps
         * @param {number} viewerFid FID of the user to fetch relevant mini apps for
         * @param {FetchRelevantFramesTimeWindowEnum} [timeWindow] Time window used to limit statistics used to calculate mini app relevance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FetchRelevantFrames200Response>} A promise that resolves to a `FetchRelevantFrames200Response` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-frames)
         *
         */
        fetchRelevantFrames: async (viewerFid, timeWindow, options = {}) => {
            // verify required parameter 'viewerFid' is not null or undefined
            (0, common_1.assertParamExists)('fetchRelevantFrames', 'viewerFid', viewerFid);
            const localVarPath = `/v2/farcaster/frame/relevant/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (viewerFid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewerFid;
            }
            if (timeWindow !== undefined) {
                localVarQueryParameter['time_window'] = timeWindow;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch analytics for total-interactors, interactors, nteractions-per-cast and input-text.
         * @summary Analytics for the mini app
         * @param {string} frameUrl URL of the mini app to fetch analytics for
         * @param {FetchValidateFrameAnalyticsAnalyticsTypeEnum} analyticsType Type of analytics to fetch
         * @param {string} start
         * @param {string} stop
         * @param {FetchValidateFrameAnalyticsAggregateWindowEnum} [aggregateWindow] Required for &#x60;analytics_type&#x3D;interactions-per-cast&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameValidateAnalyticsResponse>} A promise that resolves to a `FrameValidateAnalyticsResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-validate-frame-analytics)
         *
         */
        fetchValidateFrameAnalytics: async (frameUrl, analyticsType, start, stop, aggregateWindow, options = {}) => {
            // verify required parameter 'frameUrl' is not null or undefined
            (0, common_1.assertParamExists)('fetchValidateFrameAnalytics', 'frameUrl', frameUrl);
            // verify required parameter 'analyticsType' is not null or undefined
            (0, common_1.assertParamExists)('fetchValidateFrameAnalytics', 'analyticsType', analyticsType);
            // verify required parameter 'start' is not null or undefined
            (0, common_1.assertParamExists)('fetchValidateFrameAnalytics', 'start', start);
            // verify required parameter 'stop' is not null or undefined
            (0, common_1.assertParamExists)('fetchValidateFrameAnalytics', 'stop', stop);
            const localVarPath = `/v2/farcaster/frame/validate/analytics/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (frameUrl !== undefined) {
                localVarQueryParameter['frame_url'] = frameUrl;
            }
            if (analyticsType !== undefined) {
                localVarQueryParameter['analytics_type'] = analyticsType;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = (start instanceof Date) ?
                    start.toISOString() :
                    start;
            }
            if (stop !== undefined) {
                localVarQueryParameter['stop'] = (stop instanceof Date) ?
                    stop.toISOString() :
                    stop;
            }
            if (aggregateWindow !== undefined) {
                localVarQueryParameter['aggregate_window'] = aggregateWindow;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of all the mini apps validated by a user
         * @summary All mini apps validated by user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameValidateListResponse>} A promise that resolves to a `FrameValidateListResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-validate-frame-list)
         *
         */
        fetchValidateFrameList: async (options = {}) => {
            const localVarPath = `/v2/farcaster/frame/validate/list/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve notification delivery and opened stats for notification campaigns
         * @summary Get notification campaign stats
         * @param {string} [campaignId] An ID of a specific notification campaign to query
         * @param {number} [limit] The number of results to return  (Default: 100, Maximum: 1000)
         * @param {string} [cursor] Pagination cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<GetNotificationCampaignStats200Response>} A promise that resolves to a `GetNotificationCampaignStats200Response` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-notification-campaign-stats)
         *
         */
        getNotificationCampaignStats: async (campaignId, limit, cursor, options = {}) => {
            const localVarPath = `/v2/farcaster/frame/notifications/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (campaignId !== undefined) {
                localVarQueryParameter['campaign_id'] = campaignId;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves details about a transaction pay mini app by ID
         * @summary Get transaction pay mini app
         * @param {string} id ID of the transaction mini app to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-transaction-pay-frame)
         *
         */
        getTransactionPayFrame: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getTransactionPayFrame', 'id', id);
            const localVarPath = `/v2/farcaster/frame/transaction/pay/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a mini app either by UUID or Neynar URL
         * @summary Mini app by UUID or URL
         * @param {LookupNeynarFrameTypeEnum} type Type of identifier (either \&#39;uuid\&#39; or \&#39;url\&#39;)
         * @param {string} [uuid] UUID of the mini app to fetch
         * @param {string} [url] URL of the Neynar mini app to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-neynar-frame)
         *
         */
        lookupNeynarFrame: async (type, uuid, url, options = {}) => {
            // verify required parameter 'type' is not null or undefined
            (0, common_1.assertParamExists)('lookupNeynarFrame', 'type', type);
            const localVarPath = `/v2/farcaster/frame/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }
            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post mini app actions, cast actions or cast composer actions to the server (In order to post any of these actions, you need to have an approved `signer_uuid`)  The POST request to the post_url has a timeout of 5 seconds for mini apps.
         * @summary Post a mini app action, cast action or a cast composer action
         * @param {FrameActionReqBody} frameActionReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<Frame>} A promise that resolves to a `Frame` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/post-frame-action)
         *
         */
        postFrameAction: async (frameActionReqBody, options = {}) => {
            // verify required parameter 'frameActionReqBody' is not null or undefined
            (0, common_1.assertParamExists)('postFrameAction', 'frameActionReqBody', frameActionReqBody);
            const localVarPath = `/v2/farcaster/frame/action/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(frameActionReqBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post a mini app action that has been signed with a developer managed signer  The POST request to the post_url has a timeout of 5 seconds.
         * @summary Signature packet
         * @param {FrameDeveloperManagedActionReqBody} frameDeveloperManagedActionReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<Frame>} A promise that resolves to a `Frame` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/post-frame-action-developer-managed)
         *
         */
        postFrameActionDeveloperManaged: async (frameDeveloperManagedActionReqBody, options = {}) => {
            // verify required parameter 'frameDeveloperManagedActionReqBody' is not null or undefined
            (0, common_1.assertParamExists)('postFrameActionDeveloperManaged', 'frameDeveloperManagedActionReqBody', frameDeveloperManagedActionReqBody);
            const localVarPath = `/v2/farcaster/frame/developer_managed/action/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(frameDeveloperManagedActionReqBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send notifications to interactors of a mini app
         * @summary Send notifications
         * @param {SendFrameNotificationsReqBody} sendFrameNotificationsReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<SendFrameNotificationsResponse>} A promise that resolves to a `SendFrameNotificationsResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-frame-notifications)
         *
         */
        publishFrameNotifications: async (sendFrameNotificationsReqBody, options = {}) => {
            // verify required parameter 'sendFrameNotificationsReqBody' is not null or undefined
            (0, common_1.assertParamExists)('publishFrameNotifications', 'sendFrameNotificationsReqBody', sendFrameNotificationsReqBody);
            const localVarPath = `/v2/farcaster/frame/notifications/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(sendFrameNotificationsReqBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new mini app with a list of pages.
         * @summary Create mini app
         * @param {NeynarFrameCreationReqBody} neynarFrameCreationReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-neynar-frame)
         *
         */
        publishNeynarFrame: async (neynarFrameCreationReqBody, options = {}) => {
            // verify required parameter 'neynarFrameCreationReqBody' is not null or undefined
            (0, common_1.assertParamExists)('publishNeynarFrame', 'neynarFrameCreationReqBody', neynarFrameCreationReqBody);
            const localVarPath = `/v2/farcaster/frame/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(neynarFrameCreationReqBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for mini apps based on a query string
         * @summary Search mini apps
         * @param {string} q Query string to search for mini apps
         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)
         * @param {string} [cursor] Pagination cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-frames)
         *
         */
        searchFrames: async (q, limit, cursor, options = {}) => {
            // verify required parameter 'q' is not null or undefined
            (0, common_1.assertParamExists)('searchFrames', 'q', q);
            const localVarPath = `/v2/farcaster/frame/search/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing mini app with a list of pages, if it was made by the developer (identified by API key)
         * @summary Update mini app
         * @param {NeynarFrameUpdateReqBody} neynarFrameUpdateReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-neynar-frame)
         *
         */
        updateNeynarFrame: async (neynarFrameUpdateReqBody, options = {}) => {
            // verify required parameter 'neynarFrameUpdateReqBody' is not null or undefined
            (0, common_1.assertParamExists)('updateNeynarFrame', 'neynarFrameUpdateReqBody', neynarFrameUpdateReqBody);
            const localVarPath = `/v2/farcaster/frame/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(neynarFrameUpdateReqBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates a mini app against by an interacting user against a Farcaster Hub (In order to validate a mini app, message bytes from Frame Action must be provided in hex)
         * @summary Validate mini app action
         * @param {ValidateFrameActionReqBody} validateFrameActionReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ValidateFrameActionResponse>} A promise that resolves to a `ValidateFrameActionResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/validate-frame-action)
         *
         */
        validateFrameAction: async (validateFrameActionReqBody, options = {}) => {
            // verify required parameter 'validateFrameActionReqBody' is not null or undefined
            (0, common_1.assertParamExists)('validateFrameAction', 'validateFrameActionReqBody', validateFrameActionReqBody);
            const localVarPath = `/v2/farcaster/frame/validate/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(validateFrameActionReqBody, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.FrameApiAxiosParamCreator = FrameApiAxiosParamCreator;
/**
 * FrameApi - functional programming interface
 * @export
 */
const FrameApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.FrameApiAxiosParamCreator)(configuration);
    return {
        /**
         * Delete an existing mini app, if it was made by the developer (identified by API key)
         * @summary Delete mini app
         * @param {DeleteFrameReqBody} deleteFrameReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<DeleteFrameResponse>} A promise that resolves to a `DeleteFrameResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-neynar-frame)
         *
         */
        async deleteNeynarFrame(deleteFrameReqBody, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNeynarFrame(deleteFrameReqBody, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.deleteNeynarFrame']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A curated list of featured mini apps
         * @summary Mini apps catalog
         * @param {number} [limit] Number of results to fetch  (Default: 100, Maximum: 100)
         * @param {string} [cursor] Pagination cursor
         * @param {FetchFrameCatalogTimeWindowEnum} [timeWindow] Time window used to calculate the change in trending score for each mini app, used to sort mini app results
         * @param {Array<FetchFrameCatalogCategoriesEnum>} [categories] Comma separated list of categories to include in the results. Includes all if left blank. Example: categories&#x3D;games,social OR categories&#x3D;games&amp;categories&#x3D;social
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-catalog)
         *
         */
        async fetchFrameCatalog(limit, cursor, timeWindow, categories, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchFrameCatalog(limit, cursor, timeWindow, categories, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.fetchFrameCatalog']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches the mini app meta tags from the URL
         * @summary Meta tags from URL
         * @param {string} url The mini app URL to crawl
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FetchFrameMetaTagsFromUrl200Response>} A promise that resolves to a `FetchFrameMetaTagsFromUrl200Response` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-meta-tags-from-url)
         *
         */
        async fetchFrameMetaTagsFromUrl(url, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchFrameMetaTagsFromUrl(url, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.fetchFrameMetaTagsFromUrl']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch a list of mini apps made by the developer (identified by API key)
         * @summary List of mini apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<Array<NeynarFrame>>} A promise that resolves to a `Array<NeynarFrame>` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-neynar-frames)
         *
         */
        async fetchNeynarFrames(options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchNeynarFrames(options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.fetchNeynarFrames']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of notifications tokens related to a mini app
         * @summary List of mini app notification tokens
         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)
         * @param {string} [fids] Comma separated list of FIDs, up to 100 at a time. If you pass in FIDs, you will get back the notification tokens for those FIDs. If you don\&#39;t pass in FIDs, you will get back all the notification tokens for the mini app.
         * @param {string} [cursor] Pagination cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameNotificationTokens>} A promise that resolves to a `FrameNotificationTokens` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notification-tokens)
         *
         */
        async fetchNotificationTokens(limit, fids, cursor, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchNotificationTokens(limit, fids, cursor, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.fetchNotificationTokens']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch a list of mini apps relevant to the user based on casts by users with strong affinity score for the user
         * @summary Relevant mini apps
         * @param {number} viewerFid FID of the user to fetch relevant mini apps for
         * @param {FetchRelevantFramesTimeWindowEnum} [timeWindow] Time window used to limit statistics used to calculate mini app relevance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FetchRelevantFrames200Response>} A promise that resolves to a `FetchRelevantFrames200Response` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-frames)
         *
         */
        async fetchRelevantFrames(viewerFid, timeWindow, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRelevantFrames(viewerFid, timeWindow, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.fetchRelevantFrames']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch analytics for total-interactors, interactors, nteractions-per-cast and input-text.
         * @summary Analytics for the mini app
         * @param {string} frameUrl URL of the mini app to fetch analytics for
         * @param {FetchValidateFrameAnalyticsAnalyticsTypeEnum} analyticsType Type of analytics to fetch
         * @param {string} start
         * @param {string} stop
         * @param {FetchValidateFrameAnalyticsAggregateWindowEnum} [aggregateWindow] Required for &#x60;analytics_type&#x3D;interactions-per-cast&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameValidateAnalyticsResponse>} A promise that resolves to a `FrameValidateAnalyticsResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-validate-frame-analytics)
         *
         */
        async fetchValidateFrameAnalytics(frameUrl, analyticsType, start, stop, aggregateWindow, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchValidateFrameAnalytics(frameUrl, analyticsType, start, stop, aggregateWindow, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.fetchValidateFrameAnalytics']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch a list of all the mini apps validated by a user
         * @summary All mini apps validated by user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameValidateListResponse>} A promise that resolves to a `FrameValidateListResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-validate-frame-list)
         *
         */
        async fetchValidateFrameList(options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchValidateFrameList(options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.fetchValidateFrameList']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve notification delivery and opened stats for notification campaigns
         * @summary Get notification campaign stats
         * @param {string} [campaignId] An ID of a specific notification campaign to query
         * @param {number} [limit] The number of results to return  (Default: 100, Maximum: 1000)
         * @param {string} [cursor] Pagination cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<GetNotificationCampaignStats200Response>} A promise that resolves to a `GetNotificationCampaignStats200Response` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-notification-campaign-stats)
         *
         */
        async getNotificationCampaignStats(campaignId, limit, cursor, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationCampaignStats(campaignId, limit, cursor, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.getNotificationCampaignStats']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves details about a transaction pay mini app by ID
         * @summary Get transaction pay mini app
         * @param {string} id ID of the transaction mini app to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-transaction-pay-frame)
         *
         */
        async getTransactionPayFrame(id, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionPayFrame(id, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.getTransactionPayFrame']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch a mini app either by UUID or Neynar URL
         * @summary Mini app by UUID or URL
         * @param {LookupNeynarFrameTypeEnum} type Type of identifier (either \&#39;uuid\&#39; or \&#39;url\&#39;)
         * @param {string} [uuid] UUID of the mini app to fetch
         * @param {string} [url] URL of the Neynar mini app to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-neynar-frame)
         *
         */
        async lookupNeynarFrame(type, uuid, url, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupNeynarFrame(type, uuid, url, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.lookupNeynarFrame']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Post mini app actions, cast actions or cast composer actions to the server (In order to post any of these actions, you need to have an approved `signer_uuid`)  The POST request to the post_url has a timeout of 5 seconds for mini apps.
         * @summary Post a mini app action, cast action or a cast composer action
         * @param {FrameActionReqBody} frameActionReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<Frame>} A promise that resolves to a `Frame` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/post-frame-action)
         *
         */
        async postFrameAction(frameActionReqBody, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFrameAction(frameActionReqBody, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.postFrameAction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Post a mini app action that has been signed with a developer managed signer  The POST request to the post_url has a timeout of 5 seconds.
         * @summary Signature packet
         * @param {FrameDeveloperManagedActionReqBody} frameDeveloperManagedActionReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<Frame>} A promise that resolves to a `Frame` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/post-frame-action-developer-managed)
         *
         */
        async postFrameActionDeveloperManaged(frameDeveloperManagedActionReqBody, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFrameActionDeveloperManaged(frameDeveloperManagedActionReqBody, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.postFrameActionDeveloperManaged']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send notifications to interactors of a mini app
         * @summary Send notifications
         * @param {SendFrameNotificationsReqBody} sendFrameNotificationsReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<SendFrameNotificationsResponse>} A promise that resolves to a `SendFrameNotificationsResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-frame-notifications)
         *
         */
        async publishFrameNotifications(sendFrameNotificationsReqBody, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishFrameNotifications(sendFrameNotificationsReqBody, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.publishFrameNotifications']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new mini app with a list of pages.
         * @summary Create mini app
         * @param {NeynarFrameCreationReqBody} neynarFrameCreationReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-neynar-frame)
         *
         */
        async publishNeynarFrame(neynarFrameCreationReqBody, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishNeynarFrame(neynarFrameCreationReqBody, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.publishNeynarFrame']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for mini apps based on a query string
         * @summary Search mini apps
         * @param {string} q Query string to search for mini apps
         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)
         * @param {string} [cursor] Pagination cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-frames)
         *
         */
        async searchFrames(q, limit, cursor, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchFrames(q, limit, cursor, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.searchFrames']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing mini app with a list of pages, if it was made by the developer (identified by API key)
         * @summary Update mini app
         * @param {NeynarFrameUpdateReqBody} neynarFrameUpdateReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-neynar-frame)
         *
         */
        async updateNeynarFrame(neynarFrameUpdateReqBody, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNeynarFrame(neynarFrameUpdateReqBody, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.updateNeynarFrame']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validates a mini app against by an interacting user against a Farcaster Hub (In order to validate a mini app, message bytes from Frame Action must be provided in hex)
         * @summary Validate mini app action
         * @param {ValidateFrameActionReqBody} validateFrameActionReqBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ValidateFrameActionResponse>} A promise that resolves to a `ValidateFrameActionResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/validate-frame-action)
         *
         */
        async validateFrameAction(validateFrameActionReqBody, options) {
            var _a, _b, _c;
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateFrameAction(validateFrameActionReqBody, options);
            const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
            const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FrameApi.validateFrameAction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.FrameApiFp = FrameApiFp;
/**
 * FrameApi - factory interface
 * @export
 */
const FrameApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.FrameApiFp)(configuration);
    return {
        /**
         * Delete an existing mini app, if it was made by the developer (identified by API key)
         * @summary Delete mini app
         * @param {FrameApiDeleteNeynarFrameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<DeleteFrameResponse>} A promise that resolves to a `DeleteFrameResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-neynar-frame)
         *
         */
        deleteNeynarFrame(requestParameters, options) {
            return localVarFp.deleteNeynarFrame(requestParameters.deleteFrameReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * A curated list of featured mini apps
         * @summary Mini apps catalog
         * @param {FrameApiFetchFrameCatalogRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-catalog)
         *
         */
        fetchFrameCatalog(requestParameters = {}, options) {
            return localVarFp.fetchFrameCatalog(requestParameters.limit, requestParameters.cursor, requestParameters.timeWindow, requestParameters.categories, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the mini app meta tags from the URL
         * @summary Meta tags from URL
         * @param {FrameApiFetchFrameMetaTagsFromUrlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FetchFrameMetaTagsFromUrl200Response>} A promise that resolves to a `FetchFrameMetaTagsFromUrl200Response` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-meta-tags-from-url)
         *
         */
        fetchFrameMetaTagsFromUrl(requestParameters, options) {
            return localVarFp.fetchFrameMetaTagsFromUrl(requestParameters.url, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of mini apps made by the developer (identified by API key)
         * @summary List of mini apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<Array<NeynarFrame>>} A promise that resolves to a `Array<NeynarFrame>` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-neynar-frames)
         *
         */
        fetchNeynarFrames(options) {
            return localVarFp.fetchNeynarFrames(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of notifications tokens related to a mini app
         * @summary List of mini app notification tokens
         * @param {FrameApiFetchNotificationTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameNotificationTokens>} A promise that resolves to a `FrameNotificationTokens` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notification-tokens)
         *
         */
        fetchNotificationTokens(requestParameters = {}, options) {
            return localVarFp.fetchNotificationTokens(requestParameters.limit, requestParameters.fids, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of mini apps relevant to the user based on casts by users with strong affinity score for the user
         * @summary Relevant mini apps
         * @param {FrameApiFetchRelevantFramesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FetchRelevantFrames200Response>} A promise that resolves to a `FetchRelevantFrames200Response` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-frames)
         *
         */
        fetchRelevantFrames(requestParameters, options) {
            return localVarFp.fetchRelevantFrames(requestParameters.viewerFid, requestParameters.timeWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch analytics for total-interactors, interactors, nteractions-per-cast and input-text.
         * @summary Analytics for the mini app
         * @param {FrameApiFetchValidateFrameAnalyticsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameValidateAnalyticsResponse>} A promise that resolves to a `FrameValidateAnalyticsResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-validate-frame-analytics)
         *
         */
        fetchValidateFrameAnalytics(requestParameters, options) {
            return localVarFp.fetchValidateFrameAnalytics(requestParameters.frameUrl, requestParameters.analyticsType, requestParameters.start, requestParameters.stop, requestParameters.aggregateWindow, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all the mini apps validated by a user
         * @summary All mini apps validated by user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameValidateListResponse>} A promise that resolves to a `FrameValidateListResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-validate-frame-list)
         *
         */
        fetchValidateFrameList(options) {
            return localVarFp.fetchValidateFrameList(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve notification delivery and opened stats for notification campaigns
         * @summary Get notification campaign stats
         * @param {FrameApiGetNotificationCampaignStatsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<GetNotificationCampaignStats200Response>} A promise that resolves to a `GetNotificationCampaignStats200Response` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-notification-campaign-stats)
         *
         */
        getNotificationCampaignStats(requestParameters = {}, options) {
            return localVarFp.getNotificationCampaignStats(requestParameters.campaignId, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves details about a transaction pay mini app by ID
         * @summary Get transaction pay mini app
         * @param {FrameApiGetTransactionPayFrameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-transaction-pay-frame)
         *
         */
        getTransactionPayFrame(requestParameters, options) {
            return localVarFp.getTransactionPayFrame(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a mini app either by UUID or Neynar URL
         * @summary Mini app by UUID or URL
         * @param {FrameApiLookupNeynarFrameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-neynar-frame)
         *
         */
        lookupNeynarFrame(requestParameters, options) {
            return localVarFp.lookupNeynarFrame(requestParameters.type, requestParameters.uuid, requestParameters.url, options).then((request) => request(axios, basePath));
        },
        /**
         * Post mini app actions, cast actions or cast composer actions to the server (In order to post any of these actions, you need to have an approved `signer_uuid`)  The POST request to the post_url has a timeout of 5 seconds for mini apps.
         * @summary Post a mini app action, cast action or a cast composer action
         * @param {FrameApiPostFrameActionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<Frame>} A promise that resolves to a `Frame` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/post-frame-action)
         *
         */
        postFrameAction(requestParameters, options) {
            return localVarFp.postFrameAction(requestParameters.frameActionReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Post a mini app action that has been signed with a developer managed signer  The POST request to the post_url has a timeout of 5 seconds.
         * @summary Signature packet
         * @param {FrameApiPostFrameActionDeveloperManagedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<Frame>} A promise that resolves to a `Frame` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/post-frame-action-developer-managed)
         *
         */
        postFrameActionDeveloperManaged(requestParameters, options) {
            return localVarFp.postFrameActionDeveloperManaged(requestParameters.frameDeveloperManagedActionReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Send notifications to interactors of a mini app
         * @summary Send notifications
         * @param {FrameApiPublishFrameNotificationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<SendFrameNotificationsResponse>} A promise that resolves to a `SendFrameNotificationsResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-frame-notifications)
         *
         */
        publishFrameNotifications(requestParameters, options) {
            return localVarFp.publishFrameNotifications(requestParameters.sendFrameNotificationsReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new mini app with a list of pages.
         * @summary Create mini app
         * @param {FrameApiPublishNeynarFrameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-neynar-frame)
         *
         */
        publishNeynarFrame(requestParameters, options) {
            return localVarFp.publishNeynarFrame(requestParameters.neynarFrameCreationReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for mini apps based on a query string
         * @summary Search mini apps
         * @param {FrameApiSearchFramesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-frames)
         *
         */
        searchFrames(requestParameters, options) {
            return localVarFp.searchFrames(requestParameters.q, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing mini app with a list of pages, if it was made by the developer (identified by API key)
         * @summary Update mini app
         * @param {FrameApiUpdateNeynarFrameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-neynar-frame)
         *
         */
        updateNeynarFrame(requestParameters, options) {
            return localVarFp.updateNeynarFrame(requestParameters.neynarFrameUpdateReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates a mini app against by an interacting user against a Farcaster Hub (In order to validate a mini app, message bytes from Frame Action must be provided in hex)
         * @summary Validate mini app action
         * @param {FrameApiValidateFrameActionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<ValidateFrameActionResponse>} A promise that resolves to a `ValidateFrameActionResponse` object
         *
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/validate-frame-action)
         *
         */
        validateFrameAction(requestParameters, options) {
            return localVarFp.validateFrameAction(requestParameters.validateFrameActionReqBody, options).then((request) => request(axios, basePath));
        },
    };
};
exports.FrameApiFactory = FrameApiFactory;
/**
 * FrameApi - object-oriented interface
 * @export
 * @class FrameApi
 * @extends {BaseAPI}
 */
class FrameApi extends base_1.BaseAPI {
    /**
     * Delete an existing mini app, if it was made by the developer (identified by API key)
     * @summary Delete mini app
     * @param {FrameApiDeleteNeynarFrameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<DeleteFrameResponse>} A promise that resolves to a `DeleteFrameResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/delete-neynar-frame)
     *
     */
    deleteNeynarFrame(requestParameters, options) {
        return (0, exports.FrameApiFp)(this.configuration).deleteNeynarFrame(requestParameters.deleteFrameReqBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * A curated list of featured mini apps
     * @summary Mini apps catalog
     * @param {FrameApiFetchFrameCatalogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-catalog)
     *
     */
    fetchFrameCatalog(requestParameters = {}, options) {
        return (0, exports.FrameApiFp)(this.configuration).fetchFrameCatalog(requestParameters.limit, requestParameters.cursor, requestParameters.timeWindow, requestParameters.categories, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches the mini app meta tags from the URL
     * @summary Meta tags from URL
     * @param {FrameApiFetchFrameMetaTagsFromUrlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<FetchFrameMetaTagsFromUrl200Response>} A promise that resolves to a `FetchFrameMetaTagsFromUrl200Response` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-meta-tags-from-url)
     *
     */
    fetchFrameMetaTagsFromUrl(requestParameters, options) {
        return (0, exports.FrameApiFp)(this.configuration).fetchFrameMetaTagsFromUrl(requestParameters.url, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of mini apps made by the developer (identified by API key)
     * @summary List of mini apps
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<Array<NeynarFrame>>} A promise that resolves to a `Array<NeynarFrame>` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-neynar-frames)
     *
     */
    fetchNeynarFrames(options) {
        return (0, exports.FrameApiFp)(this.configuration).fetchNeynarFrames(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of notifications tokens related to a mini app
     * @summary List of mini app notification tokens
     * @param {FrameApiFetchNotificationTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<FrameNotificationTokens>} A promise that resolves to a `FrameNotificationTokens` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notification-tokens)
     *
     */
    fetchNotificationTokens(requestParameters = {}, options) {
        return (0, exports.FrameApiFp)(this.configuration).fetchNotificationTokens(requestParameters.limit, requestParameters.fids, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of mini apps relevant to the user based on casts by users with strong affinity score for the user
     * @summary Relevant mini apps
     * @param {FrameApiFetchRelevantFramesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<FetchRelevantFrames200Response>} A promise that resolves to a `FetchRelevantFrames200Response` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-frames)
     *
     */
    fetchRelevantFrames(requestParameters, options) {
        return (0, exports.FrameApiFp)(this.configuration).fetchRelevantFrames(requestParameters.viewerFid, requestParameters.timeWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch analytics for total-interactors, interactors, nteractions-per-cast and input-text.
     * @summary Analytics for the mini app
     * @param {FrameApiFetchValidateFrameAnalyticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<FrameValidateAnalyticsResponse>} A promise that resolves to a `FrameValidateAnalyticsResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-validate-frame-analytics)
     *
     */
    fetchValidateFrameAnalytics(requestParameters, options) {
        return (0, exports.FrameApiFp)(this.configuration).fetchValidateFrameAnalytics(requestParameters.frameUrl, requestParameters.analyticsType, requestParameters.start, requestParameters.stop, requestParameters.aggregateWindow, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of all the mini apps validated by a user
     * @summary All mini apps validated by user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<FrameValidateListResponse>} A promise that resolves to a `FrameValidateListResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-validate-frame-list)
     *
     */
    fetchValidateFrameList(options) {
        return (0, exports.FrameApiFp)(this.configuration).fetchValidateFrameList(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve notification delivery and opened stats for notification campaigns
     * @summary Get notification campaign stats
     * @param {FrameApiGetNotificationCampaignStatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<GetNotificationCampaignStats200Response>} A promise that resolves to a `GetNotificationCampaignStats200Response` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-notification-campaign-stats)
     *
     */
    getNotificationCampaignStats(requestParameters = {}, options) {
        return (0, exports.FrameApiFp)(this.configuration).getNotificationCampaignStats(requestParameters.campaignId, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves details about a transaction pay mini app by ID
     * @summary Get transaction pay mini app
     * @param {FrameApiGetTransactionPayFrameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-transaction-pay-frame)
     *
     */
    getTransactionPayFrame(requestParameters, options) {
        return (0, exports.FrameApiFp)(this.configuration).getTransactionPayFrame(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a mini app either by UUID or Neynar URL
     * @summary Mini app by UUID or URL
     * @param {FrameApiLookupNeynarFrameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-neynar-frame)
     *
     */
    lookupNeynarFrame(requestParameters, options) {
        return (0, exports.FrameApiFp)(this.configuration).lookupNeynarFrame(requestParameters.type, requestParameters.uuid, requestParameters.url, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Post mini app actions, cast actions or cast composer actions to the server (In order to post any of these actions, you need to have an approved `signer_uuid`)  The POST request to the post_url has a timeout of 5 seconds for mini apps.
     * @summary Post a mini app action, cast action or a cast composer action
     * @param {FrameApiPostFrameActionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<Frame>} A promise that resolves to a `Frame` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/post-frame-action)
     *
     */
    postFrameAction(requestParameters, options) {
        return (0, exports.FrameApiFp)(this.configuration).postFrameAction(requestParameters.frameActionReqBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Post a mini app action that has been signed with a developer managed signer  The POST request to the post_url has a timeout of 5 seconds.
     * @summary Signature packet
     * @param {FrameApiPostFrameActionDeveloperManagedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<Frame>} A promise that resolves to a `Frame` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/post-frame-action-developer-managed)
     *
     */
    postFrameActionDeveloperManaged(requestParameters, options) {
        return (0, exports.FrameApiFp)(this.configuration).postFrameActionDeveloperManaged(requestParameters.frameDeveloperManagedActionReqBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Send notifications to interactors of a mini app
     * @summary Send notifications
     * @param {FrameApiPublishFrameNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<SendFrameNotificationsResponse>} A promise that resolves to a `SendFrameNotificationsResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-frame-notifications)
     *
     */
    publishFrameNotifications(requestParameters, options) {
        return (0, exports.FrameApiFp)(this.configuration).publishFrameNotifications(requestParameters.sendFrameNotificationsReqBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new mini app with a list of pages.
     * @summary Create mini app
     * @param {FrameApiPublishNeynarFrameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-neynar-frame)
     *
     */
    publishNeynarFrame(requestParameters, options) {
        return (0, exports.FrameApiFp)(this.configuration).publishNeynarFrame(requestParameters.neynarFrameCreationReqBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search for mini apps based on a query string
     * @summary Search mini apps
     * @param {FrameApiSearchFramesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-frames)
     *
     */
    searchFrames(requestParameters, options) {
        return (0, exports.FrameApiFp)(this.configuration).searchFrames(requestParameters.q, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update an existing mini app with a list of pages, if it was made by the developer (identified by API key)
     * @summary Update mini app
     * @param {FrameApiUpdateNeynarFrameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<NeynarFrame>} A promise that resolves to a `NeynarFrame` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/update-neynar-frame)
     *
     */
    updateNeynarFrame(requestParameters, options) {
        return (0, exports.FrameApiFp)(this.configuration).updateNeynarFrame(requestParameters.neynarFrameUpdateReqBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Validates a mini app against by an interacting user against a Farcaster Hub (In order to validate a mini app, message bytes from Frame Action must be provided in hex)
     * @summary Validate mini app action
     * @param {FrameApiValidateFrameActionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<ValidateFrameActionResponse>} A promise that resolves to a `ValidateFrameActionResponse` object
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/validate-frame-action)
     *
     */
    validateFrameAction(requestParameters, options) {
        return (0, exports.FrameApiFp)(this.configuration).validateFrameAction(requestParameters.validateFrameActionReqBody, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FrameApi = FrameApi;
/**
 * @export
 */
exports.FetchFrameCatalogTimeWindowEnum = {
    _1h: '1h',
    _6h: '6h',
    _12h: '12h',
    _24h: '24h',
    _7d: '7d'
};
/**
 * @export
 */
exports.FetchFrameCatalogCategoriesEnum = {
    Games: 'games',
    Social: 'social',
    Finance: 'finance',
    Utility: 'utility',
    Productivity: 'productivity',
    HealthFitness: 'health-fitness',
    NewsMedia: 'news-media',
    Music: 'music',
    Shopping: 'shopping',
    Education: 'education',
    DeveloperTools: 'developer-tools',
    Entertainment: 'entertainment',
    ArtCreativity: 'art-creativity'
};
/**
 * @export
 */
exports.FetchRelevantFramesTimeWindowEnum = {
    _1h: '1h',
    _6h: '6h',
    _12h: '12h',
    _24h: '24h',
    _7d: '7d'
};
/**
 * @export
 */
exports.FetchValidateFrameAnalyticsAnalyticsTypeEnum = {
    TotalInteractors: 'total-interactors',
    Interactors: 'interactors',
    InteractionsPerCast: 'interactions-per-cast',
    InputText: 'input-text'
};
/**
 * @export
 */
exports.FetchValidateFrameAnalyticsAggregateWindowEnum = {
    _10s: '10s',
    _1m: '1m',
    _2m: '2m',
    _5m: '5m',
    _10m: '10m',
    _20m: '20m',
    _30m: '30m',
    _2h: '2h',
    _12h: '12h',
    _1d: '1d',
    _7d: '7d'
};
/**
 * @export
 */
exports.LookupNeynarFrameTypeEnum = {
    Uuid: 'uuid',
    Url: 'url'
};
