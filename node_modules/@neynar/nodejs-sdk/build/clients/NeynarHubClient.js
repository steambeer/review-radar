"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NeynarHubClient = void 0;
const logger_1 = require("../common/logger");
const axios_1 = __importStar(require("axios"));
const configuration_1 = require("../hub-api/configuration");
const casts_api_1 = require("../hub-api/apis/casts-api");
const fids_api_1 = require("../hub-api/apis/fids-api");
const hub_events_api_1 = require("../hub-api/apis/hub-events-api");
const info_api_1 = require("../hub-api/apis/info-api");
const links_api_1 = require("../hub-api/apis/links-api");
const message_api_1 = require("../hub-api/apis/message-api");
const on_chain_events_api_1 = require("../hub-api/apis/on-chain-events-api");
const reactions_api_1 = require("../hub-api/apis/reactions-api");
const storage_api_1 = require("../hub-api/apis/storage-api");
const user_data_api_1 = require("../hub-api/apis/user-data-api");
const usernames_api_1 = require("../hub-api/apis/usernames-api");
const verifications_api_1 = require("../hub-api/apis/verifications-api");
const { version: sdkVersion } = require("../../package.json");
/**
 * Converts a camelCase string to snake_case.
 * If the input string is not in camelCase format, it returns the original string.
 *
 * @param {string} str - The string to convert.
 * @returns {string} The converted string in snake_case, or the original string if not camelCase.
 */
function camelToSnakeCase(str) {
    // Check if the string is camelCase
    if (/^[a-z]+([A-Z][a-z]*)+$/.test(str)) {
        return str.replace(/([A-Z])/g, '_$1').toLowerCase();
    }
    return str; // Return the original string if it's not camelCase
}
/**
 * Converts the top-level keys of an object from camelCase to snake_case.
 * If a key is not in camelCase, it retains its original format.
 * Nested objects or arrays are left unchanged.
 * This is done to revert the conversion of top-level keys since we accept snake_case keys in the API but convert them to camelCase in the wrapper.
 *
 * @param {object} obj - The object whose top-level keys are to be converted.
 * @returns {object} A new object with top-level keys converted to snake_case.
 */
function camelCaseToSnakeCaseKeys(obj) {
    if (obj && typeof obj === 'object' && !Array.isArray(obj)) {
        // Convert only the top-level keys
        return Object.fromEntries(Object.entries(obj).map(([key, value]) => [
            camelToSnakeCase(key), // Convert only camelCase keys
            value, // Leave the value untouched
        ]));
    }
    return obj; // If not an object, return as is
}
class NeynarHubClient {
    constructor(config, options = {}) {
        if (typeof config === 'string') {
            console.error('Error: config must be of type Configuration');
            console.log(`
Seems, like you are using sdk v2 but the syntax on client instantiation is for sdk v1.
SDK v1 -> v2 migration guide: https://docs.neynar.com/reference/neynar-nodejs-sdk-v1-to-v2-migration-guide

Correct usage way to instantiate the client:

import { NeynarHubClient, Configuration } from "@neynar/nodejs-sdk";

const config = new Configuration({
  apiKey: "API_KEY",
  baseOptions: {
    headers: {
      "x-neynar-experimental": true,
    },
  },
});

const client = new NeynarHubClient(config);\n`);
            throw new Error('Invalid configuration type. Expected Configuration object but received string.');
        }
        const { logger = logger_1.silentLogger, axiosInstance: customAxiosInstance } = options;
        this.logger = logger;
        this.config = new configuration_1.Configuration({
            apiKey: config.apiKey,
            basePath: config.basePath,
            baseOptions: config.baseOptions,
        });
        const axiosInstance = customAxiosInstance || axios_1.default.create({
            headers: {
                "x-sdk-version": sdkVersion,
                "x-sdk": "node"
            },
        });
        axiosInstance.defaults.decompress = true;
        axiosInstance.interceptors.response.use((response) => response, (error) => {
            if (error.response && [302].includes(error.response.status)) {
                return {
                    data: {
                        location: error.response.headers.location,
                    },
                };
            }
            if (NeynarHubClient.isApiErrorResponse(error)) {
                const apiErrors = error.response.data;
                this.logger.warn(`API errors: ${JSON.stringify(apiErrors)}`);
            }
            throw error;
        });
        this.apis = {
            castsApi: new casts_api_1.CastsApi(this.config, undefined, axiosInstance),
            fidsApi: new fids_api_1.FidsApi(this.config, undefined, axiosInstance),
            hubEventsApi: new hub_events_api_1.HubEventsApi(this.config, undefined, axiosInstance),
            infoApi: new info_api_1.InfoApi(this.config, undefined, axiosInstance),
            linksApi: new links_api_1.LinksApi(this.config, undefined, axiosInstance),
            messageApi: new message_api_1.MessageApi(this.config, undefined, axiosInstance),
            onChainEventsApi: new on_chain_events_api_1.OnChainEventsApi(this.config, undefined, axiosInstance),
            reactionsApi: new reactions_api_1.ReactionsApi(this.config, undefined, axiosInstance),
            storageApi: new storage_api_1.StorageApi(this.config, undefined, axiosInstance),
            userDataApi: new user_data_api_1.UserDataApi(this.config, undefined, axiosInstance),
            usernamesApi: new usernames_api_1.UsernamesApi(this.config, undefined, axiosInstance),
            verificationsApi: new verifications_api_1.VerificationsApi(this.config, undefined, axiosInstance),
        };
    }
    static isApiErrorResponse(error) {
        var _a;
        if (!(error instanceof axios_1.AxiosError))
            return false;
        return (((_a = error.response) === null || _a === void 0 ? void 0 : _a.data) !== undefined && "message" in error.response.data);
    }
    /**
     * Retrieve all reply casts (responses) to a specific parent cast in the Farcaster network. Parent casts can be identified using either a combination of FID and hash, or by their URL. This endpoint enables traversal of conversation threads and retrieval of all responses to a particular cast.
     *
     * @summary By parent cast
     *
     * @param {object} params
     * @param {number} params.fid [optional]  - The Farcaster ID (FID) of the parent cast's creator. This parameter must be used together with the 'hash' parameter to uniquely identify a parent cast. Required only when using hash-based lookup instead of URL-based lookup. The FID is a unique identifier assigned to each Farcaster user.
     * @param {string} params.hash [optional]  - The unique hash identifier of the parent cast. Must be used together with the 'fid' parameter when doing hash-based lookup. This is a 40-character hexadecimal string prefixed with '0x' that uniquely identifies the cast within the creator's posts. Not required if using URL-based lookup.
     * @param {string} params.url [optional]  - Cast URL starting with 'chain://'
     * @param {number} params.pageSize [optional]  - Maximum number of messages to return in a single response
     * @param {boolean} params.reverse [optional]  - Reverse the sort order, returning latest messages first
     * @param {string} params.pageToken [optional]  - The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
     *
     * @returns {Promise<FetchCastsByParent200Response>} A promise that resolves to a `FetchCastsByParent200Response` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const hash =
     * const url =
     * const pageSize =
     * const reverse =
     * const pageToken =
     *
     * client.fetchCastsByParent({ fid, hash, url, pageSize, reverse, pageToken }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-casts-by-parent)
     *
     */
    async fetchCastsByParent(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.castsApi.fetchCastsByParent(adjustedParams);
        return response.data;
    }
    /**
     * Fetch casts mentioning a user.
     *
     * @summary Mentioning an FID
     *
     * @param {object} params
     * @param {number} params.fid  - The FID that is mentioned in a cast
     * @param {number} params.pageSize [optional]  - Maximum number of messages to return in a single response
     * @param {boolean} params.reverse [optional]  - Reverse the sort order, returning latest messages first
     * @param {string} params.pageToken [optional]  - The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
     *
     * @returns {Promise<FetchUsersCasts200Response>} A promise that resolves to a `FetchUsersCasts200Response` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const pageSize =
     * const reverse =
     * const pageToken =
     *
     * client.fetchCastsMentioningUser({ fid, pageSize, reverse, pageToken }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-casts-mentioning-user)
     *
     */
    async fetchCastsMentioningUser(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.castsApi.fetchCastsMentioningUser(adjustedParams);
        return response.data;
    }
    /**
     * Fetch user\'s casts.
     *
     * @summary By FID
     *
     * @param {object} params
     * @param {number} params.fid  - The FID of the casts' creator
     * @param {number} params.pageSize [optional]  - Maximum number of messages to return in a single response
     * @param {boolean} params.reverse [optional]  - Reverse the sort order, returning latest messages first
     * @param {string} params.pageToken [optional]  - The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
     *
     * @returns {Promise<FetchUsersCasts200Response>} A promise that resolves to a `FetchUsersCasts200Response` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const pageSize =
     * const reverse =
     * const pageToken =
     *
     * client.fetchUsersCasts({ fid, pageSize, reverse, pageToken }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-users-casts)
     *
     */
    async fetchUsersCasts(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.castsApi.fetchUsersCasts(adjustedParams);
        return response.data;
    }
    /**
     * Lookup a cast by its FID and hash.
     *
     * @summary By FID and Hash
     *
     * @param {object} params
     * @param {number} params.fid  - The FID of the cast's creator
     * @param {string} params.hash  - The unique hash identifier of the cast. This is a 40-character hexadecimal string prefixed with '0x' that uniquely identifies a specific cast in the Farcaster network.
     *
     * @returns {Promise<CastAdd>} A promise that resolves to a `CastAdd` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const hash =
     *
     * client.lookupCastByHashAndFid({ fid, hash }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-cast-by-hash-and-fid)
     *
     */
    async lookupCastByHashAndFid(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.castsApi.lookupCastByHashAndFid(adjustedParams);
        return response.data;
    }
    /**
     * Fetch a list of all the FIDs.
     *
     * @summary Fetch a list of all the FIDs
     *
     * @param {object} params
     * @param {number} params.shardId  - The shard ID to filter by
     * @param {number} params.pageSize [optional]  - Maximum number of messages to return in a single response
     * @param {boolean} params.reverse [optional]  - Reverse the sort order, returning latest messages first
     * @param {string} params.pageToken [optional]  - The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
     *
     * @returns {Promise<FidsResponse>} A promise that resolves to a `FidsResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const shardId =
     * const pageSize =
     * const reverse =
     * const pageToken =
     *
     * client.fetchFids({ shardId, pageSize, reverse, pageToken }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-fids)
     *
     */
    async fetchFids(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.fidsApi.fetchFids(adjustedParams);
        return response.data;
    }
    /**
     * Fetch a list of events.
     *
     * @summary Page of events
     *
     * @param {object} params
     * @param {number} params.fromEventId [optional]  - An optional Hub Id to start getting events from. This is also returned from the API as nextPageEventId, which can be used to page through all the Hub events. Set it to 0 to start from the first event.
     *
     * @returns {Promise<FetchEvents200Response>} A promise that resolves to a `FetchEvents200Response` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fromEventId =
     *
     * client.fetchEvents({ fromEventId }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-events)
     *
     */
    async fetchEvents(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.hubEventsApi.fetchEvents(adjustedParams);
        return response.data;
    }
    /**
     * Lookup an event by its ID.
     *
     * @summary Event by ID
     *
     * @param {object} params
     * @param {number} params.eventId  - The Hub Id of the event
     *
     * @returns {Promise<HubEvent>} A promise that resolves to a `HubEvent` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const eventId =
     *
     * client.lookupEvent({ eventId }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-event)
     *
     */
    async lookupEvent(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.hubEventsApi.lookupEvent(adjustedParams);
        return response.data;
    }
    /**
     * Retrieve hub information.
     *
     * @summary Sync Methods
     *
     * @param {object} params
     * @param {boolean} params.dbstats  - Controls whether the response includes database statistics. When true, the response includes information about the hub's database state, storage usage, and performance metrics.
     *
     * @returns {Promise<HubInfoResponse>} A promise that resolves to a `HubInfoResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const dbstats =
     *
     * client.lookupHubInfo({ dbstats }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-hub-info)
     *
     */
    async lookupHubInfo(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.infoApi.lookupHubInfo(adjustedParams);
        return response.data;
    }
    /**
     * Fetch a list of users that are following a user.
     *
     * @summary To target FID
     *
     * @param {object} params
     * @param {number} params.targetFid  - The FID of the target user for this link
     * @param {LinkType} params.linkType [optional]
     * @param {number} params.pageSize [optional]  - Maximum number of messages to return in a single response
     * @param {boolean} params.reverse [optional]  - Reverse the sort order, returning latest messages first
     * @param {string} params.pageToken [optional]  - The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
     *
     * @returns {Promise<FetchUserFollowing200Response>} A promise that resolves to a `FetchUserFollowing200Response` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const targetFid =
     * const linkType =
     * const pageSize =
     * const reverse =
     * const pageToken =
     *
     * client.fetchUserFollowers({ targetFid, linkType, pageSize, reverse, pageToken }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-followers)
     *
     */
    async fetchUserFollowers(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.linksApi.fetchUserFollowers(adjustedParams);
        return response.data;
    }
    /**
     * Fetch a list of users that a user is following.
     *
     * @summary From source FID
     *
     * @param {object} params
     * @param {number} params.fid  - The FID of the link's originator
     * @param {LinkType} params.linkType [optional]
     * @param {number} params.pageSize [optional]  - Maximum number of messages to return in a single response
     * @param {boolean} params.reverse [optional]  - Reverse the sort order, returning latest messages first
     * @param {string} params.pageToken [optional]  - The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
     *
     * @returns {Promise<FetchUserFollowing200Response>} A promise that resolves to a `FetchUserFollowing200Response` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const linkType =
     * const pageSize =
     * const reverse =
     * const pageToken =
     *
     * client.fetchUserFollowing({ fid, linkType, pageSize, reverse, pageToken }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-following)
     *
     */
    async fetchUserFollowing(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.linksApi.fetchUserFollowing(adjustedParams);
        return response.data;
    }
    /**
     * Lookup a link by its FID and target FID.
     *
     * @summary By its FID and target FID
     *
     * @param {object} params
     * @param {number} params.fid  - The FID of the link's originator
     * @param {number} params.targetFid  - The FID of the target user for this link
     * @param {LinkType} params.linkType
     *
     * @returns {Promise<LinkAdd>} A promise that resolves to a `LinkAdd` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const targetFid =
     * const linkType =
     *
     * client.lookupUserRelation({ fid, targetFid, linkType }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-relation)
     *
     */
    async lookupUserRelation(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.linksApi.lookupUserRelation(adjustedParams);
        return response.data;
    }
    /**
     * Submit a message to the Farcaster network.
     *
     * @summary Submit signed message
     *
     * @param {object} params
     * @param {File} params.body  - A Message is a delta operation on the Farcaster network. The message protobuf is an envelope that wraps a MessageData object and contains a hash and signature which can verify its authenticity.
     *
     * @returns {Promise<Message>} A promise that resolves to a `Message` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const body =
     *
     * client.publishMessage({ body }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/submit-signed-message)
     *
     */
    async publishMessage(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.messageApi.publishMessage(adjustedParams);
        return response.data;
    }
    /**
     * Validate a message on the Farcaster network.
     *
     * @summary Validate signed message
     *
     * @param {object} params
     * @param {File} params.body  - A Message is a delta operation on the Farcaster network. The message protobuf is an envelope that wraps a MessageData object and contains a hash and signature which can verify its authenticity.
     *
     * @returns {Promise<ValidateMessageResponse>} A promise that resolves to a `ValidateMessageResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const body =
     *
     * client.validateMessage({ body }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/validate-message)
     *
     */
    async validateMessage(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.messageApi.validateMessage(adjustedParams);
        return response.data;
    }
    /**
     * Fetch on-chain events provided by a user.
     *
     * @summary Fetch a list of on-chain events provided by an FID
     *
     * @param {object} params
     * @param {number} params.fid  - The FID being requested
     * @param {OnChainEventType} params.eventType  - The numeric or string value of the event type being requested
     *
     * @returns {Promise<FetchUserOnChainEvents200Response>} A promise that resolves to a `FetchUserOnChainEvents200Response` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const eventType =
     *
     * client.fetchUserOnChainEvents({ fid, eventType }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-on-chain-events)
     *
     */
    async fetchUserOnChainEvents(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.onChainEventsApi.fetchUserOnChainEvents(adjustedParams);
        return response.data;
    }
    /**
     * **Note:** one of two different response schemas is returned based on whether the caller provides the `signer` parameter. If included, a single `OnChainEventSigner` message is returned (or a `not_found` error). If omitted, a non-paginated list of `OnChainEventSigner` messages is returned instead.
     *
     * @summary Fetch a list of signers provided by an FID
     *
     * @param {object} params
     * @param {number} params.fid  - The FID being requested
     * @param {string} params.signer [optional]  - The optional key of signer
     *
     * @returns {Promise<FetchUserOnChainSignersEvents200Response>} A promise that resolves to a `FetchUserOnChainSignersEvents200Response` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const signer =
     *
     * client.fetchUserOnChainSignersEvents({ fid, signer }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-on-chain-signers)
     *
     */
    async fetchUserOnChainSignersEvents(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.onChainEventsApi.fetchUserOnChainSignersEvents(adjustedParams);
        return response.data;
    }
    /**
     * Fetch an on-chain ID Registry Event for a given Address.
     *
     * @summary Fetch an on-chain ID Registry Event for a given Address
     *
     * @param {object} params
     * @param {string} params.address  - The ETH address being requested
     *
     * @returns {Promise<OnChainEventIdRegister>} A promise that resolves to a `OnChainEventIdRegister` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const address =
     *
     * client.lookupOnChainIdRegistryEventByAddress({ address }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-on-chain-id-registry-event-by-address)
     *
     */
    async lookupOnChainIdRegistryEventByAddress(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.onChainEventsApi.lookupOnChainIdRegistryEventByAddress(adjustedParams);
        return response.data;
    }
    /**
     * Retrieve all reactions (likes or recasts) on a specific cast in the Farcaster network. The cast is identified by its creator\'s FID and unique hash. This endpoint helps track engagement metrics and user interactions with specific content.
     *
     * @summary On cast
     *
     * @param {object} params
     * @param {number} params.targetFid  - The FID of the cast's creator. Required to uniquely identify the cast that received the reactions. Must be used in conjunction with target_hash.
     * @param {string} params.targetHash  - The unique hash identifier of the cast that received the reactions. This is a 40-character hexadecimal string prefixed with '0x' that uniquely identifies the cast within the creator's posts. Must be used with target_fid.
     * @param {ReactionType} params.reactionType
     * @param {number} params.pageSize [optional]  - Maximum number of messages to return in a single response
     * @param {boolean} params.reverse [optional]  - Reverse the sort order, returning latest messages first
     * @param {string} params.pageToken [optional]  - The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
     *
     * @returns {Promise<FetchCastReactions200Response>} A promise that resolves to a `FetchCastReactions200Response` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const targetFid =
     * const targetHash =
     * const reactionType =
     * const pageSize =
     * const reverse =
     * const pageToken =
     *
     * client.fetchCastReactions({ targetFid, targetHash, reactionType, pageSize, reverse, pageToken }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-cast-reactions)
     *
     */
    async fetchCastReactions(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.reactionsApi.fetchCastReactions(adjustedParams);
        return response.data;
    }
    /**
     * Fetch all reactions of a specific type (like or recast) that target a given URL. This endpoint is useful for tracking engagement with content across the Farcaster network.
     *
     * @summary To a target URL
     *
     * @param {object} params
     * @param {string} params.url  - Target URL starting with 'chain://'.
     * @param {ReactionType} params.reactionType [optional]
     * @param {number} params.pageSize [optional]  - Maximum number of messages to return in a single response
     * @param {boolean} params.reverse [optional]  - Reverse the sort order, returning latest messages first
     * @param {string} params.pageToken [optional]  - The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
     *
     * @returns {Promise<FetchCastReactions200Response>} A promise that resolves to a `FetchCastReactions200Response` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const url =
     * const reactionType =
     * const pageSize =
     * const reverse =
     * const pageToken =
     *
     * client.fetchReactionsByTarget({ url, reactionType, pageSize, reverse, pageToken }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-reactions-by-target)
     *
     */
    async fetchReactionsByTarget(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.reactionsApi.fetchReactionsByTarget(adjustedParams);
        return response.data;
    }
    /**
     * Fetch reactions by a user.
     *
     * @summary By FID
     *
     * @param {object} params
     * @param {number} params.fid  - The FID of the reaction's creator
     * @param {ReactionType} params.reactionType
     * @param {number} params.pageSize [optional]  - Maximum number of messages to return in a single response
     * @param {boolean} params.reverse [optional]  - Reverse the sort order, returning latest messages first
     * @param {string} params.pageToken [optional]  - The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
     *
     * @returns {Promise<FetchCastReactions200Response>} A promise that resolves to a `FetchCastReactions200Response` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const reactionType =
     * const pageSize =
     * const reverse =
     * const pageToken =
     *
     * client.fetchUserReactions({ fid, reactionType, pageSize, reverse, pageToken }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-reactions)
     *
     */
    async fetchUserReactions(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.reactionsApi.fetchUserReactions(adjustedParams);
        return response.data;
    }
    /**
     * Lookup a reaction by its FID or cast.
     *
     * @summary By FID or cast
     *
     * @param {object} params
     * @param {number} params.fid  - The FID of the reaction's creator
     * @param {number} params.targetFid  - The FID of the cast's creator
     * @param {string} params.targetHash  - The cast's hash
     * @param {ReactionType} params.reactionType
     *
     * @returns {Promise<Reaction>} A promise that resolves to a `Reaction` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const targetFid =
     * const targetHash =
     * const reactionType =
     *
     * client.lookupReactionById({ fid, targetFid, targetHash, reactionType }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-reaction-by-id)
     *
     */
    async lookupReactionById(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.reactionsApi.lookupReactionById(adjustedParams);
        return response.data;
    }
    /**
     * Fetch a user\'s storage limits.
     *
     * @summary FID\'s limits
     *
     * @param {object} params
     * @param {number} params.fid
     *
     * @returns {Promise<StorageLimitsResponse>} A promise that resolves to a `StorageLimitsResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     *
     * client.lookupUserStorageLimit({ fid }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/lookup-user-storage-limit)
     *
     */
    async lookupUserStorageLimit(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.storageApi.lookupUserStorageLimit(adjustedParams);
        return response.data;
    }
    /**
     * **Note:** one of two different response schemas is returned based on whether the caller provides the `user_data_type` parameter. If included, a single `UserDataAdd` message is returned (or a `not_found` error). If omitted, a paginated list of `UserDataAdd` messages is returned instead.
     *
     * @summary Fetch UserData for a FID
     *
     * @param {object} params
     * @param {number} params.fid  - The FID that's being requested
     * @param {UserDataType} params.userDataType [optional]  - The type of user data, either as a numerical value or type string. If this is omitted, all user data for the FID is returned
     * @param {number} params.pageSize [optional]  - Maximum number of messages to return in a single response
     * @param {boolean} params.reverse [optional]  - Reverse the sort order, returning latest messages first
     * @param {string} params.pageToken [optional]  - The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
     *
     * @returns {Promise<FetchUserData200Response>} A promise that resolves to a `FetchUserData200Response` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const userDataType =
     * const pageSize =
     * const reverse =
     * const pageToken =
     *
     * client.fetchUserData({ fid, userDataType, pageSize, reverse, pageToken }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-user-data)
     *
     */
    async fetchUserData(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.userDataApi.fetchUserData(adjustedParams);
        return response.data;
    }
    /**
     * Fetch a proof for a username.
     *
     * @summary Proof for a username
     *
     * @param {object} params
     * @param {string} params.name  - The Farcaster username or ENS address
     *
     * @returns {Promise<UserNameProof>} A promise that resolves to a `UserNameProof` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const name =
     *
     * client.fetchUsernameProofByName({ name }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-username-proof-by-name)
     *
     */
    async fetchUsernameProofByName(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.usernamesApi.fetchUsernameProofByName(adjustedParams);
        return response.data;
    }
    /**
     * Fetch proofs provided by a user.
     *
     * @summary Proofs provided by an FID
     *
     * @param {object} params
     * @param {number} params.fid  - The FID being requested
     *
     * @returns {Promise<UsernameProofsResponse>} A promise that resolves to a `UsernameProofsResponse` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     *
     * client.fetchUsernameProofsByFid({ fid }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-username-proofs-by-fid)
     *
     */
    async fetchUsernameProofsByFid(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.usernamesApi.fetchUsernameProofsByFid(adjustedParams);
        return response.data;
    }
    /**
     * Fetch verifications provided by a user.
     *
     * @summary Provided by an FID
     *
     * @param {object} params
     * @param {number} params.fid  - The FID being requested
     * @param {string} params.address [optional]  - The optional ETH address to filter by
     * @param {number} params.pageSize [optional]  - Maximum number of messages to return in a single response
     * @param {boolean} params.reverse [optional]  - Reverse the sort order, returning latest messages first
     * @param {string} params.pageToken [optional]  - The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
     *
     * @returns {Promise<FetchVerificationsByFid200Response>} A promise that resolves to a `FetchVerificationsByFid200Response` object.
     *
     * @example
     *
     * // Fill in the appropriate values
     * const fid =
     * const address =
     * const pageSize =
     * const reverse =
     * const pageToken =
     *
     * client.fetchVerificationsByFid({ fid, address, pageSize, reverse, pageToken }).then(response => {
     *   console.log('response:', response);
     * });
     *
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-verifications-by-fid)
     *
     */
    async fetchVerificationsByFid(params) {
        const adjustedParams = {};
        Object.assign(adjustedParams, params);
        const response = await this.apis.verificationsApi.fetchVerificationsByFid(adjustedParams);
        return response.data;
    }
}
exports.NeynarHubClient = NeynarHubClient;
